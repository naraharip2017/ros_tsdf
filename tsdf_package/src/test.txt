void testVoxelBlockTraversal(TSDFContainer * tsdfContainer, Vector3f * occupiedVoxels_h, int * index_h){
  // float f = 10.23423;
  int size = 5;
  pcl::PointXYZ * point1 = new pcl::PointXYZ(.75,.75, 0.75);
  pcl::PointXYZ * point2 = new pcl::PointXYZ(1.5,1.5, 1.5);
  pcl::PointXYZ * point3 = new pcl::PointXYZ(-.85,-.85, -.85);
  pcl::PointXYZ * point4 = new pcl::PointXYZ(.90,.90, .90);
  pcl::PointXYZ * point5 = new pcl::PointXYZ(.65,.56, .65);
  
  pcl::PointXYZ * points_h = new pcl::PointXYZ[size];
  points_h[0] = *point1;
  points_h[1] = *point2;
  points_h[2] = *point3;
  points_h[3] = *point4;
  points_h[4] = *point5;
  pcl::PointXYZ * points_d;
  cudaMalloc(&points_d, sizeof(*points_h)*size);
  cudaMemcpy(points_d, points_h, sizeof(*points_h)*size, cudaMemcpyHostToDevice);

  int maxBlocks = 1000;
  Vector3f pointcloud_voxel_blocks_h[maxBlocks]; //make these member functions of tsdf_handler if cant pass device reference on host code
  Vector3f * pointCloudVoxelBlocks_d;
  int * pointer_h = new int(0);
  int * pointer_d;
  cudaMalloc(&pointCloudVoxelBlocks_d, sizeof(*pointcloud_voxel_blocks_h)*maxBlocks);
  cudaMemcpy(pointCloudVoxelBlocks_d, pointcloud_voxel_blocks_h, sizeof(*pointCloudVoxelBlocks_h)*maxBlocks,cudaMemcpyHostToDevice); //do I even need to memcpy
  cudaMalloc(&pointer_d, sizeof(*pointer_h));
  cudaMemcpy(pointer_d, pointer_h, sizeof(*pointer_h), cudaMemcpyHostToDevice);

  Vector3f * origin_transformed_h = new Vector3f(0,0,0);
  Vector3f * origin_transformed_d;
  cudaMalloc(&origin_transformed_d, sizeof(*origin_transformed_h));
  cudaMemcpy(origin_transformed_d, origin_transformed_h,sizeof(*origin_transformed_h),cudaMemcpyHostToDevice);

  int numCudaBlocks = size / threadsPerCudaBlock + 1;

  int * size_d;
  cudaMalloc(&size_d, sizeof(int));
  cudaMemcpy(size_d, &size, sizeof(int), cudaMemcpyHostToDevice);

  getVoxelBlocksForPoint<<<numCudaBlocks,threadsPerCudaBlock>>>(points_d, pointCloudVoxelBlocks_d, pointer_d, origin_transformed_d, size_d);

  // printVoxelBlocksFromPoint<<<1,1>>>(pointCloudVoxelBlocks_d, pointer_d);

  cudaDeviceSynchronize();

  cudaMemcpy(pointCloudVoxelBlocks_h, pointCloudVoxelBlocks_d, sizeof(*pointCloudVoxelBlocks_h)*maxBlocks,cudaMemcpyDeviceToHost);
  cudaMemcpy(pointer_h, pointer_d, sizeof(*pointer_h), cudaMemcpyDeviceToHost);

  printf("num voxel blocks: %d\n", *pointer_h);

  // tsdfContainer->integrateVoxelBlockPointsIntoHashTable(pointCloudVoxelBlocks_h, *pointer_h);

  HashTable * hashTable_d = tsdfContainer->getCudaHashTable();

  BlockHeap * blockHeap_d = tsdfContainer->getCudaBlockHeap();
  getVoxelsForPoint<<<numCudaBlocks,threadsPerCudaBlock>>>(points_d, origin_transformed_d, hashTable_d, blockHeap_d, size_d);

  cudaDeviceSynchronize();

  Vector3f * occupiedVoxels_d;
  int * index_d;
  cudaMalloc(&occupiedVoxels_d, sizeof(*occupiedVoxels_h)*100);
  cudaMemcpy(occupiedVoxels_d, occupiedVoxels_h, sizeof(*occupiedVoxels_h)*100,cudaMemcpyHostToDevice);
  cudaMalloc(&index_d, sizeof(*index_h));
  cudaMemcpy(index_d, index_h, sizeof(*index_h), cudaMemcpyHostToDevice);

  int numVisVoxBlocks = HASH_TABLE_SIZE / 128 + 1;
  // printf("hash table size: %d\n", HASH_TABLE_SIZE);
  visualizeOccupiedVoxels<<<numVisVoxBlocks,128>>>(hashTable_d, blockHeap_d, occupiedVoxels_d, index_d);

  cudaDeviceSynchronize();

  cudaMemcpy(occupiedVoxels_h, occupiedVoxels_d, sizeof(*occupiedVoxels_h)*100, cudaMemcpyDeviceToHost);
  cudaMemcpy(index_h, index_d, sizeof(int), cudaMemcpyDeviceToHost);

  // for(int i=0; i < *index_h; ++i){
  //   printf("occupied voxel: (%f, %f, %f)\n", occupiedVoxels_h[i](0), occupiedVoxels_h[i](1), occupiedVoxels_h[i](2));
  // }

  // printf("occupied voxels: %d\n", *index_h);

}

void testVoxelTraversal(){
  int size = 2;
  pcl::PointXYZ * point1 = new pcl::PointXYZ(-73.4567,33.576, 632.8910);
  pcl::PointXYZ * point2 = new pcl::PointXYZ(-7.23421,-278, 576.2342);
  pcl::PointXYZ * points_h = new pcl::PointXYZ[size];
  points_h[0] = *point1;
  points_h[1] = *point2;
  pcl::PointXYZ * points_d;
  cudaMalloc(&points_d, sizeof(*points_h)*size);
  cudaMemcpy(points_d, points_h, sizeof(*points_h)*size, cudaMemcpyHostToDevice);

  

  // Vector3f * voxels_h = new Vector3f[size];
  // Vector3f * voxels_d;
  // Vector3f A;
  // A(0) = -1*(VOXEL_SIZE/2);
  // A(1) = -1*(VOXEL_SIZE/2);
  // A(2) = -1*(VOXEL_SIZE/2);
  // voxels_h[0] = A;
  // // Vector3f B;
  // // B(0) = 10/26;
  // // B(1) = 5/26;
  // // B(2) = 5/26;
  // // voxels_h[1] = B;
  // // Vector3f C;
  // // C(0) = 5/26;
  // // C(1) = 10/26;
  // // C(2) = 5/26;
  // // voxels_h[2] = C;
  // // Vector3f D;
  // // D(0) = -0.75;
  // // D(1) = -0.75;
  // // D(2) = -0.25;
  // // voxels_h[3] = D;
  // // Vector3f E;
  // // E(0) = -0.25;
  // // E(1) = -0.25;
  // // E(2) = -0.75;
  // // voxels_h[4] = E;
  // // Vector3f F;
  // // F(0) = -0.75;
  // // F(1) = -0.25;
  // // F(2) = -0.75;
  // // voxels_h[5] = F;
  // // Vector3f G;
  // // G(0) = -0.25;
  // // G(1) = -0.75;
  // // G(2) = -0.75;
  // // voxels_h[6] = G;
  // // Vector3f H;
  // // H(0) = -0.05;
  // // H(1) = -0.05;
  // // H(2) = -0.05;
  // // voxels_h[7] = H;
  

  // cudaMalloc(&voxels_d, sizeof(*voxels_h)*size);
  // cudaMemcpy(voxels_d,voxels_h, sizeof(*voxels_h)*size, cudaMemcpyHostToDevice);

  // updateVoxels<<<1,size>>>(voxels_d);

  // cudaDeviceSynchronize();

}